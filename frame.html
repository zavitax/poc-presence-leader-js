<!DOCTYPE html>
<html>
    <body>
        <script src="eventEmitter.js"></script>
        <script src="eventRealtimeClient.js"></script>
        <script src="presenceRealtimeClient.js"></script>
        <script src="leaderElectionRealtimeClient.js"></script>
        <script src="coordinatedMessageQueueRealtimeClient.js"></script>
        <script src="distributedStateRealtimeClient.js"></script>

        <div id="debug"></div>
        <div id="aux"></div>
        <div id="status"></div>
        <div id="aux_status"></div>

        <script>
            const uuid = crypto.randomUUID();

            async function main() {
                function sleep(ms) {
                    return new Promise(resolve => {
                        setTimeout(resolve, ms);
                    });
                }

                function debug(...args) {
                    document.getElementById("debug").innerText = JSON.stringify([ ... args ]);
                    //console.log(uuid, ...args);
                }

                function aux(...args) {
                    document.getElementById("aux").innerText = JSON.stringify([ ... args ]);
                }

                function status(...args) {
                    document.getElementById("status").innerText = JSON.stringify([ ... args ]);
                }

                function aux_status(...args) {
                    document.getElementById("aux_status").innerText = JSON.stringify([ ... args ]);
                }

                function color(bgColor = 'inherit') {
                    document.body.style.backgroundColor = bgColor;
                }

                debug('wait');

                //await sleep(Math.floor(10000 * Math.random()));

                debug('start');
                color('#eeeeee');

                function createRealtimeEventEmitterProvider() {
                    return new WebsocketRealtimeEventEmitterProvider({
                        websocketUrl: 'ws://localhost:8080',
                    });
                    /*
                    return new BroadcastChannelRealtimeEventEmitterProvider({
                        broadcastChannelName: 'test',
                    });*/
                }

                function strcmp(av, bv) {
                    if (av < bv) return -1;
                    if (av > bv) return 1;
                    return 0;
                }

                function statecmp(a, b) {
                    const r1 = strcmp(a?.data?.timestamp, b?.data?.timestamp);
                    
                    if (r1 !== 0) return r1;

                    return strcmp(a?.data?.nonce, b?.data?.nonce);
                }

                /*
                const queue = [];

                const distributedStateRealtimeClient = new DistributedStateRealtimeClient({
                    presenceRealtimeClient: new PresenceRealtimeClient({
                        eventRealtimeClient: new EventRealtimeClient({
                            realtimeEventEmitterProvider: createRealtimeEventEmitterProvider(),
                        }),
                        heartbeatIntervalMilliseconds: 5000,
                    }),
                    warmupTimeMilliseconds: 15000,
                    compareStateCallback: (a, b) => {
                        // Prefer older state to catch up to
                        return statecmp(b, a);
                    },
                });

                const queueEventRealtimeClient = new EventRealtimeClient({
                    realtimeEventEmitterProvider: createRealtimeEventEmitterProvider(),
                });

                function remove_stale_queue_items() {
                    const state = distributedStateRealtimeClient.presenceRealtimeClient.localState;

                    // Remove older than state items from queue
                    while (queue.length && statecmp(state, queue[0]) === -1) {
                        queue.shift();
                    }
                }

                function process_queue_item(item) {
                    return new Promise(resolve => {
                        setTimeout(resolve, Math.round(Math.random() * 15000));
                    });
                }

                function update_state() {
                    console.log('queue: ', queue);
                    if (queue.length > 0) {
                        console.log('has state');
                        distributedStateRealtimeClient.presenceRealtimeClient.localState = {
                            timestamp: queue[0].timestamp,
                            nonce: queue[0].nonce,
                            key: queue[0].key,
                        };
                    } else {
                        console.log('no state');
                        distributedStateRealtimeClient.presenceRealtimeClient.localState = {
                            timestamp: 0,
                            nonce: '',
                            key: null,
                        };
                    }

                    status(distributedStateRealtimeClient.presenceRealtimeClient.localState);
                }

                function process_next_queue_item() {
                    remove_stale_queue_items();

                    if (queue.length === 0) return;
                    if (!distributedStateRealtimeClient.synchronized) return;

                    const item = queue[0];

                    aux_status('processing: ', item);
                    process_queue_item(item).finally(() => {
                        aux_status('idle: ');

                        update_state();

                        queue.shift();

                        remove_stale_queue_items();
                    });
                }

                queueEventRealtimeClient.on('queue:item', ({ data }) => {
                    remove_stale_queue_items();

                    //aux('queue: ', data);
                    queue.push(data);

                    process_next_queue_item();
                });

                distributedStateRealtimeClient.on('emptyState', () => {
                    console.log('emptyState');
                    debug('emptyState');
                    color('#8888ee');
                    
                    update_state();
                });

                distributedStateRealtimeClient.on('sync', () => {
                    debug('sync');
                    color('#88ee88');

                    status(distributedStateRealtimeClient.presenceRealtimeClient.localState);
                    process_next_queue_item();
                });

                distributedStateRealtimeClient.on('desync', () => {
                    debug('desync');
                    color('#ee8888');
                });
                */

                const leaderElectionRealtimeClient = new LeaderElectionRealtimeClient({
                    presenceRealtimeClient: new PresenceRealtimeClient({
                        eventRealtimeClient: new EventRealtimeClient({
                            realtimeEventEmitterProvider: createRealtimeEventEmitterProvider(),
                        }),
                        heartbeatIntervalMilliseconds: 5000,
                    }),
                    requestSortParticipantsCallback: (a, b) => {
                        const av = a.data.key;
                        const bv = b.data.key;

                        if (av < bv) return -1;
                        if (av > bv) return 1;
                        return 0;
                    },
                });

                leaderElectionRealtimeClient.presenceRealtimeClient.localState = { key: uuid };

                const coordinatedMessageQueueRealtimeClient = new CoordinatedMessageQueueRealtimeClient({
                    leaderElectionRealtimeClient,
                    eventRealtimeClient: new EventRealtimeClient({
                        realtimeEventEmitterProvider: createRealtimeEventEmitterProvider(),
                    }),
                });

                leaderElectionRealtimeClient.on('leaderStateChanged', ({ isLeader }) => {
                    debug(
                        'isLeader: ',
                        leaderElectionRealtimeClient.isLeader
                    );

                    if (leaderElectionRealtimeClient.isLeader) {
                        color('#88ee88');
                    } else {
                        color('#ee8888');
                    }
                });

                aux(
                    'init participants: ',
                    leaderElectionRealtimeClient.presenceRealtimeClient.participants.length
                );
                leaderElectionRealtimeClient.presenceRealtimeClient.on('change', () => {
                    aux(
                        'participants: ',
                        leaderElectionRealtimeClient.presenceRealtimeClient.participants.length
                    );
                });

                coordinatedMessageQueueRealtimeClient.on('message', event => {
                    const { src, ack, ackToken, data } = event;

                    if (!leaderElectionRealtimeClient.isLeader) {
                        color("#eeeeee");
                    } else {
                        color('#88ee88');
                    }

                    const delayMs = Math.floor(Math.random() * 3000);

                    status('got event: from ', src, ' -> ', data.data, '    ack delayMs: ', delayMs);;

                    setTimeout(() => {
                        //console.log(uuid, ' ack()');

                        ack();

                        if (!leaderElectionRealtimeClient.isLeader) {
                            color("#aaaaaa");
                        } else {
                            color('#44aa44');
                        }
                    }, delayMs);
                });

                await sleep(6000);

                let i = 0;
                function enqueue() {
                    ++i;
                    if (coordinatedMessageQueueRealtimeClient.queue.length < 10) {
                        coordinatedMessageQueueRealtimeClient.enqueue({ data: { seq: i } });
                    }
                    setTimeout(enqueue, 1000);
                }
                enqueue();

                window.onbeforeunload = function(event) {
                    event.preventDefault();

                    coordinatedMessageQueueRealtimeClient.dispose();

                    event.returnValue = "test";
                }

                /*
                debug('dispose');
                color('#888888');
                //await leaderElectionRealtimeClient.dispose();
                await coordinatedMessageQueueRealtimeClient.dispose();
                debug('disposed');
                color('#444444');
                */
            }

            main();
        </script>
    </body>
</html>